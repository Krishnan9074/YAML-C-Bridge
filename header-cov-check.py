import yaml
import textwrap
import re

# --- Step 1: Read and Pre-process the YAML file ---

yaml_file_path = 'compare.yaml'

try:
    # Open and read the YAML file as plain text
    with open(yaml_file_path, 'r') as f:
        yaml_text = f.read()

    # --- Pre-process the text to fix structural errors ---
    # This section specifically looks for the 'value:' and 'opcode:' keys
    # appearing on the same line and splits them into two valid lines,
    # carefully preserving the original indentation for both.
    corrected_lines = []
    for line in yaml_text.splitlines():
        
        if 'value:' in line and 'opcode:' in line:
            # Find the original indentation of the line
            indentation = len(line) - len(line.lstrip(' '))
            indent_str = ' ' * indentation
            
            # Split the line at the 'opcode:' key
            parts = line.split('opcode:', 1)
            
            # Reconstruct the 'value:' line, stripping extra space but keeping indentation
            value_line = indent_str + parts[0].strip()
            corrected_lines.append(value_line)
            
            # Reconstruct the 'opcode:' line on a new line, preserving indentation
            opcode_line = indent_str + 'opcode:' + parts[1]
            corrected_lines.append(opcode_line)
        else:
            # If the line is fine, add it as is.
            corrected_lines.append(line)
            
    pre_processed_text = '\n'.join(corrected_lines)

    # --- Second, add quotes to binary values to preserve them as strings ---
    # This regex now runs on the structurally corrected YAML text.
    modified_yaml_text = re.sub(
        r'^(.*\bvalue:\s*)(0b[01]+)\s*$',
        r'\1"\2"',
        pre_processed_text,
        flags=re.MULTILINE
    )

    # Now, parse the fully corrected YAML string
    data = yaml.safe_load(modified_yaml_text)
    print(f"Successfully parsed YAML file: {yaml_file_path}")

except FileNotFoundError:
    # On the second pass, we'll be looking for 'generated.yaml'
    try:
        yaml_file_path = 'compare.yaml'
        with open(yaml_file_path, 'r') as f:
            data = yaml.safe_load(f)
        print(f"Successfully parsed YAML file: {yaml_file_path}")
    except (FileNotFoundError, yaml.YAMLError) as e:
        print(f"Error: Neither 'xnor.yaml' nor 'generated.yaml' could be found or parsed.")
        print(f"Details: {e}")
        exit(1)
except yaml.YAMLError as e:
    print(f"Error parsing YAML from '{yaml_file_path}': {e}")
    exit(1)


# --- Data Extraction ---
# This logic now handles both the original nested format and the generated flat format.
inst_name = data.get('name', 'unknown')
inst_long_name = data.get('long_name', 'Unknown Instruction')
inst_assembly = data.get('assembly', 'unknown')
inst_description = data.get('description', 'No description.').strip()

# **THE FIX**: Check if the data is nested (from original file) or flat (from generated file)
if 'format' in data and isinstance(data.get('format'), dict) and 'opcodes' in data['format']:
    # Handle the nested structure from the original xnor.yaml
    print("Parsing nested YAML structure.")
    opcodes = data['format']['opcodes']
    inst_funct7 = opcodes.get('funct7', {}).get('value', '0b0')
    inst_funct3 = opcodes.get('funct3', {}).get('value', '0b0')
    # For the original file, we hardcode the opcode based on the spec
    inst_opcode = '0b0110011'
else:
    # Handle the flat structure from the generated.yaml file
    print("Parsing flat YAML structure.")
    inst_funct7 = data.get('funct7', '0b0')
    inst_funct3 = data.get('funct3', '0b0')
    inst_opcode = data.get('opcode', '0b0')


# --- Step 2: Emit the data as a C header file ---

# Format the multi-line description for a C string literal.
c_description = ' \\\n'.join(f'"{line}"' for line in inst_description.split('\n'))


# Create the C header content using an f-string template.
header_template = f"""
/*
 * This file is auto-generated by a Python script.
 * DO NOT EDIT MANUALLY.
 */

#ifndef INSTRUCTION_H
#define INSTRUCTION_H

// A structure to hold RISC-V instruction data
typedef struct {{
    const char* name;
    const char* long_name;
    const char* assembly;
    const char* description;
    const char* funct7;
    const char* funct3;
    const char* opcode;
}} RiscVInstruction;

// Static instance containing the data from the YAML file
static const RiscVInstruction instruction_data = {{
    /* name        */ "{inst_name}",
    /* long_name   */ "{inst_long_name}",
    /* assembly    */ "{inst_assembly}",
    /* description */ {c_description},
    /* funct7      */ "{inst_funct7}",
    /* funct3      */ "{inst_funct3}",
    /* opcode      */ "{inst_opcode}"
}};

#endif // INSTRUCTION_H
"""

# Write the content to 'instruction.h'
try:
    with open('instruction.h', 'w') as f:
        f.write(textwrap.dedent(header_template).strip())
    print("Successfully generated C header file: instruction.h")
except IOError as e:
    print(f"Error writing to file: {e}")